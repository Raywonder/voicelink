import Foundation
import SwiftUI

// MARK: - Pairing Manager
class PairingManager: ObservableObject {
    static let shared = PairingManager()

    // Current pairing code (generated by server)
    @Published var currentPairingCode: String?
    @Published var pairingCodeExpiry: Date?
    @Published var isPairingMode: Bool = false

    // Linked servers
    @Published var linkedServers: [LinkedServer] = []
    @Published var ownedServers: [OwnedServer] = []

    // Pairing state
    @Published var pairingStatus: PairingStatus = .idle
    @Published var pairingError: String?

    // Community membership level system
    @Published var membershipLevel: MembershipLevel = .newbie
    @Published var membershipStats: MembershipStats = MembershipStats()
    @Published var complaints: Int = 0
    @Published var trustScore: Int = 100  // Trust score starts at 100, goes down with complaints

    // Device limits based on membership level
    var maxLinkedDevices: Int {
        membershipLevel.maxDevices + paidTier.bonusDevices
    }

    var canUpgradeLevel: Bool {
        membershipStats.canUpgradeTo(level: membershipLevel.nextLevel) && trustScore >= 50
    }

    // Trust score affects upgrade eligibility
    var trustLevel: TrustLevel {
        TrustLevel.from(score: trustScore)
    }

    enum TrustLevel: String {
        case excellent = "Excellent"
        case good = "Good"
        case fair = "Fair"
        case poor = "Poor"
        case banned = "Banned"

        var color: String {
            switch self {
            case .excellent: return "green"
            case .good: return "blue"
            case .fair: return "yellow"
            case .poor: return "orange"
            case .banned: return "red"
            }
        }

        var icon: String {
            switch self {
            case .excellent: return "checkmark.shield.fill"
            case .good: return "shield.fill"
            case .fair: return "shield.lefthalf.filled"
            case .poor: return "exclamationmark.shield.fill"
            case .banned: return "xmark.shield.fill"
            }
        }

        var canUpgrade: Bool {
            switch self {
            case .excellent, .good: return true
            case .fair, .poor, .banned: return false
            }
        }

        static func from(score: Int) -> TrustLevel {
            switch score {
            case 80...100: return .excellent
            case 60..<80: return .good
            case 40..<60: return .fair
            case 1..<40: return .poor
            default: return .banned
            }
        }
    }

    // MARK: - Membership Level System

    enum MembershipLevel: Int, Codable, CaseIterable {
        case newbie = 1        // Level 1 - Starting level
        case regular = 2       // Level 2 - Active user
        case outstanding = 3   // Level 3 - Outstanding community member

        var displayName: String {
            switch self {
            case .newbie: return "Newbie"
            case .regular: return "Regular"
            case .outstanding: return "Outstanding"
            }
        }

        var description: String {
            switch self {
            case .newbie: return "New community member - 1 device, 2 rooms"
            case .regular: return "Active member - 2 devices, 5 rooms"
            case .outstanding: return "Outstanding member - 3 devices, 10 rooms"
            }
        }

        var maxDevices: Int {
            switch self {
            case .newbie: return 1
            case .regular: return 2
            case .outstanding: return 3
            }
        }

        var maxRooms: Int {
            switch self {
            case .newbie: return 2
            case .regular: return 5
            case .outstanding: return 10
            }
        }

        var icon: String {
            switch self {
            case .newbie: return "star"
            case .regular: return "star.leadinghalf.filled"
            case .outstanding: return "star.fill"
            }
        }

        var color: String {
            switch self {
            case .newbie: return "gray"
            case .regular: return "blue"
            case .outstanding: return "gold"
            }
        }

        var nextLevel: MembershipLevel? {
            switch self {
            case .newbie: return .regular
            case .regular: return .outstanding
            case .outstanding: return nil
            }
        }

        var requiredDaysActive: Int {
            switch self {
            case .newbie: return 0
            case .regular: return 7      // 7 days to reach level 2
            case .outstanding: return 30 // 30 days to reach level 3
            }
        }

        var requiredRoomHours: Int {
            switch self {
            case .newbie: return 0
            case .regular: return 5      // 5 hours in rooms
            case .outstanding: return 20 // 20 hours in rooms
            }
        }

        var maxComplaints: Int {
            switch self {
            case .newbie: return 3       // 3 complaints pushes back
            case .regular: return 2      // 2 complaints can demote
            case .outstanding: return 1  // Very strict at top level
            }
        }
    }

    struct MembershipStats: Codable {
        var firstJoinDate: Date = Date()
        var daysActive: Int = 0
        var totalRoomHours: Double = 0
        var roomsCreated: Int = 0
        var helpfulActions: Int = 0  // Helping others, moderating, etc.
        var lastActivityDate: Date = Date()

        func canUpgradeTo(level: MembershipLevel?) -> Bool {
            guard let level = level else { return false }
            return daysActive >= level.requiredDaysActive &&
                   Int(totalRoomHours) >= level.requiredRoomHours
        }

        mutating func recordActivity() {
            let calendar = Calendar.current
            if !calendar.isDateInToday(lastActivityDate) {
                daysActive += 1
            }
            lastActivityDate = Date()
        }

        mutating func addRoomTime(hours: Double) {
            totalRoomHours += hours
        }
    }

    // Paid tiers (in addition to free levels)
    enum PaidTier: String, Codable {
        case none = "None"
        case supporter = "Supporter"
        case unlimited = "Unlimited"

        var bonusDevices: Int {
            switch self {
            case .none: return 0
            case .supporter: return 7      // +7 devices (total 10 at level 3)
            case .unlimited: return 97     // +97 devices (total 100)
            }
        }

        var bonusRooms: Int {
            switch self {
            case .none: return 0
            case .supporter: return 15     // +15 rooms
            case .unlimited: return 90     // Unlimited rooms
            }
        }
    }

    @Published var paidTier: PaidTier = .none

    // Combined limits
    var totalMaxDevices: Int {
        membershipLevel.maxDevices + paidTier.bonusDevices
    }

    var totalMaxRooms: Int {
        membershipLevel.maxRooms + paidTier.bonusRooms
    }

    enum PairingStatus {
        case idle
        case generatingCode
        case waitingForPair
        case pairing
        case paired
        case failed
    }

    init() {
        loadLinkedServers()
    }

    // MARK: - Pairing Code Generation (Server Side)

    func generatePairingCode() -> String {
        // Generate 6-digit alphanumeric code
        let characters = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789" // Removed confusing chars (0, O, 1, I)
        let code = String((0..<6).map { _ in characters.randomElement()! })

        DispatchQueue.main.async {
            self.currentPairingCode = code
            self.pairingCodeExpiry = Date().addingTimeInterval(60) // 60 second expiry
            self.isPairingMode = true
            self.pairingStatus = .waitingForPair
        }

        // Start expiry timer
        startExpiryTimer()

        return code
    }

    private func startExpiryTimer() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 60) { [weak self] in
            guard let self = self else { return }
            if self.isPairingMode && self.pairingStatus == .waitingForPair {
                self.cancelPairing()
            }
        }
    }

    func cancelPairing() {
        DispatchQueue.main.async {
            self.currentPairingCode = nil
            self.pairingCodeExpiry = nil
            self.isPairingMode = false
            self.pairingStatus = .idle
        }
    }

    // MARK: - Pairing Code Entry (Client Side)

    func enterPairingCode(_ code: String, serverURL: String, authMethod: AuthMethod = .pairingCode, completion: @escaping (Bool, String?) -> Void) {
        pairingStatus = .pairing

        // Send pairing request to server
        guard let url = URL(string: "\(serverURL)/api/pair") else {
            completion(false, "Invalid server URL")
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        // Build request body with auth info
        var body: [String: Any] = [
            "code": code.uppercased(),
            "clientId": getClientId(),
            "clientName": Host.current().localizedName ?? "Unknown Device",
            "authMethod": authMethod.rawValue
        ]

        // Add authentication token if user is authenticated
        if let user = AuthenticationManager.shared.currentUser {
            body["authToken"] = user.accessToken
            body["authUserId"] = user.id
            body["authUsername"] = user.username
            if let instance = user.mastodonInstance {
                body["mastodonInstance"] = instance
            }
            if let email = user.email {
                body["email"] = email
            }
        }

        request.httpBody = try? JSONSerialization.data(withJSONObject: body)

        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    self?.pairingStatus = .failed
                    self?.pairingError = error.localizedDescription
                    completion(false, error.localizedDescription)
                    return
                }

                guard let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let success = json["success"] as? Bool else {
                    self?.pairingStatus = .failed
                    self?.pairingError = "Invalid response from server"
                    completion(false, "Invalid response from server")
                    return
                }

                if success {
                    // Save linked server
                    if let serverInfo = json["server"] as? [String: Any] {
                        let authUser = AuthenticationManager.shared.currentUser
                        let server = LinkedServer(
                            id: serverInfo["id"] as? String ?? UUID().uuidString,
                            name: serverInfo["name"] as? String ?? "Server",
                            url: serverURL,
                            ownerId: serverInfo["ownerId"] as? String,
                            pairedAt: Date(),
                            accessToken: json["accessToken"] as? String,
                            authMethod: authMethod,
                            authUserId: authUser?.id,
                            authUsername: authUser?.fullHandle
                        )
                        self?.addLinkedServer(server)
                    }

                    self?.pairingStatus = .paired
                    completion(true, nil)
                } else {
                    let errorMsg = json["error"] as? String ?? "Pairing failed"
                    self?.pairingStatus = .failed
                    self?.pairingError = errorMsg
                    completion(false, errorMsg)
                }
            }
        }.resume()
    }

    // MARK: - Local Network Discovery

    func discoverLocalServers(completion: @escaping ([DiscoveredServer]) -> Void) {
        var discovered: [DiscoveredServer] = []

        // Check common ports for VoiceLink servers
        let ports = [4004, 3010, 8080]
        let group = DispatchGroup()

        for port in ports {
            group.enter()
            let url = "http://localhost:\(port)/api/info"

            guard let requestURL = URL(string: url) else {
                group.leave()
                continue
            }

            var request = URLRequest(url: requestURL)
            request.timeoutInterval = 2

            URLSession.shared.dataTask(with: request) { data, response, error in
                defer { group.leave() }

                guard let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let serverName = json["name"] as? String else {
                    return
                }

                let server = DiscoveredServer(
                    name: serverName,
                    url: "http://localhost:\(port)",
                    port: port,
                    serverId: json["id"] as? String,
                    isPaired: self.isServerPaired(url: "http://localhost:\(port)")
                )

                DispatchQueue.main.async {
                    discovered.append(server)
                }
            }.resume()
        }

        group.notify(queue: .main) {
            completion(discovered)
        }
    }

    // MARK: - Linked Servers Management

    func addLinkedServer(_ server: LinkedServer) {
        guard linkedServers.count < maxLinkedDevices else {
            pairingError = "Maximum \(maxLinkedDevices) devices can be linked"
            return
        }

        // Check if already linked
        if !linkedServers.contains(where: { $0.url == server.url }) {
            linkedServers.append(server)
            saveLinkedServers()

            // Send notification
            NotificationCenter.default.post(
                name: .serverLinked,
                object: server,
                userInfo: ["server": server]
            )
        }
    }

    func unlinkServer(_ server: LinkedServer) {
        linkedServers.removeAll { $0.id == server.id }
        saveLinkedServers()

        // Notify server of unlink
        if let url = URL(string: "\(server.url)/api/unlink") {
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue(server.accessToken, forHTTPHeaderField: "Authorization")

            let body: [String: Any] = ["clientId": getClientId()]
            request.httpBody = try? JSONSerialization.data(withJSONObject: body)

            URLSession.shared.dataTask(with: request).resume()
        }

        NotificationCenter.default.post(name: .serverUnlinked, object: server)
    }

    func isServerPaired(url: String) -> Bool {
        return linkedServers.contains { $0.url == url }
    }

    // MARK: - Membership Level Management

    func checkForLevelUpgrade() {
        // Check if user qualifies for next level
        guard let nextLevel = membershipLevel.nextLevel,
              membershipStats.canUpgradeTo(level: nextLevel),
              complaints < membershipLevel.maxComplaints else {
            return
        }

        // Auto-upgrade
        membershipLevel = nextLevel
        saveMembershipData()

        // Notify UI
        NotificationCenter.default.post(name: .membershipLevelChanged, object: membershipLevel)
    }

    func recordActivity() {
        membershipStats.recordActivity()
        saveMembershipData()
        checkForLevelUpgrade()
    }

    func recordRoomTime(hours: Double) {
        membershipStats.addRoomTime(hours: hours)
        saveMembershipData()
        checkForLevelUpgrade()
    }

    func receiveComplaint(reason: String, severity: ComplaintSeverity = .minor) {
        complaints += 1
        trustScore = max(0, trustScore - severity.trustPenalty)
        saveMembershipData()

        // Check for demotion based on trust score or complaints
        if complaints >= membershipLevel.maxComplaints || trustScore < 40 {
            // Demote to previous level or prevent upgrades
            switch membershipLevel {
            case .outstanding:
                membershipLevel = .regular
                complaints = 0  // Reset after demotion
            case .regular:
                membershipLevel = .newbie
                complaints = 0
            case .newbie:
                // Can't demote further, but can't upgrade until complaints cleared
                break
            }
            saveMembershipData()
            NotificationCenter.default.post(name: .membershipLevelChanged, object: membershipLevel)
        }

        // Notify about trust score change
        NotificationCenter.default.post(name: .trustScoreChanged, object: trustScore)
    }

    enum ComplaintSeverity: String, Codable {
        case minor = "minor"      // -5 trust
        case moderate = "moderate" // -15 trust
        case severe = "severe"     // -30 trust
        case critical = "critical" // -50 trust (ban-worthy)

        var trustPenalty: Int {
            switch self {
            case .minor: return 5
            case .moderate: return 15
            case .severe: return 30
            case .critical: return 50
            }
        }
    }

    func clearComplaint() {
        // Called by server when a complaint expires or is resolved
        complaints = max(0, complaints - 1)
        // Recover some trust over time
        trustScore = min(100, trustScore + 5)
        saveMembershipData()
    }

    func recoverTrust(amount: Int = 1) {
        // Called periodically by server for good behavior
        trustScore = min(100, trustScore + amount)
        saveMembershipData()
        NotificationCenter.default.post(name: .trustScoreChanged, object: trustScore)
    }

    // Sync membership data with server
    func syncMembershipWithServer(serverURL: String, completion: @escaping (Bool) -> Void) {
        guard let url = URL(string: "\(serverURL)/api/membership/sync") else {
            completion(false)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let body: [String: Any] = [
            "clientId": getClientId(),
            "level": membershipLevel.rawValue,
            "daysActive": membershipStats.daysActive,
            "roomHours": membershipStats.totalRoomHours,
            "complaints": complaints
        ]

        request.httpBody = try? JSONSerialization.data(withJSONObject: body)

        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            DispatchQueue.main.async {
                guard let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                    completion(false)
                    return
                }

                // Update from server response
                if let serverLevel = json["level"] as? Int,
                   let level = MembershipLevel(rawValue: serverLevel) {
                    self?.membershipLevel = level
                }
                if let serverComplaints = json["complaints"] as? Int {
                    self?.complaints = serverComplaints
                }
                if let stats = json["stats"] as? [String: Any] {
                    self?.membershipStats.daysActive = stats["daysActive"] as? Int ?? self?.membershipStats.daysActive ?? 0
                    self?.membershipStats.totalRoomHours = stats["roomHours"] as? Double ?? self?.membershipStats.totalRoomHours ?? 0
                }

                self?.saveMembershipData()
                completion(true)
            }
        }.resume()
    }

    // MARK: - Paid Tier Management

    func upgradePaidTier(to tier: PaidTier, paymentAmount: Double?, paymentMethod: PaymentMethod?, completion: @escaping (Bool, String?) -> Void) {
        guard let amount = paymentAmount, amount > 0 else {
            completion(false, "Please enter an amount to support.")
            return
        }

        // Process payment (mock implementation)
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in
            self?.paidTier = tier
            self?.saveMembershipData()
            completion(true, nil)
        }
    }

    enum PaymentMethod: String, CaseIterable {
        case ecrypto = "eCrypto"
        case paypal = "PayPal"
        case stripe = "Card"
        case applePay = "Apple Pay"
    }

    // MARK: - NFT/Wallet Display Data

    struct MembershipNFTData: Codable {
        let level: Int
        let levelName: String
        let maxDevices: Int
        let maxRooms: Int
        let daysActive: Int
        let roomHours: Double
        let memberSince: Date
        let trustScore: Int
        let trustLevel: String
        let paidTier: String
        let walletAddress: String?

        static func from(manager: PairingManager) -> MembershipNFTData {
            return MembershipNFTData(
                level: manager.membershipLevel.rawValue,
                levelName: manager.membershipLevel.displayName,
                maxDevices: manager.totalMaxDevices,
                maxRooms: manager.totalMaxRooms,
                daysActive: manager.membershipStats.daysActive,
                roomHours: manager.membershipStats.totalRoomHours,
                memberSince: manager.membershipStats.firstJoinDate,
                trustScore: manager.trustScore,
                trustLevel: manager.trustLevel.rawValue,
                paidTier: manager.paidTier.rawValue,
                walletAddress: UserDefaults.standard.string(forKey: "walletAddress")
            )
        }
    }

    func getMembershipNFTData() -> MembershipNFTData {
        return MembershipNFTData.from(manager: self)
    }

    // MARK: - Persistence

    private func loadLinkedServers() {
        if let data = UserDefaults.standard.data(forKey: "linkedServers"),
           let servers = try? JSONDecoder().decode([LinkedServer].self, from: data) {
            linkedServers = servers
        }

        if let data = UserDefaults.standard.data(forKey: "ownedServers"),
           let servers = try? JSONDecoder().decode([OwnedServer].self, from: data) {
            ownedServers = servers
        }

        // Load membership data
        loadMembershipData()
    }

    private func loadMembershipData() {
        // Load membership level
        if let levelRaw = UserDefaults.standard.object(forKey: "membershipLevel") as? Int,
           let level = MembershipLevel(rawValue: levelRaw) {
            membershipLevel = level
        }

        // Load membership stats
        if let data = UserDefaults.standard.data(forKey: "membershipStats"),
           let stats = try? JSONDecoder().decode(MembershipStats.self, from: data) {
            membershipStats = stats
        }

        // Load paid tier
        if let tierString = UserDefaults.standard.string(forKey: "paidTier"),
           let tier = PaidTier(rawValue: tierString) {
            paidTier = tier
        }

        // Load trust and complaints
        complaints = UserDefaults.standard.integer(forKey: "complaints")
        trustScore = UserDefaults.standard.object(forKey: "trustScore") as? Int ?? 100
    }

    private func saveLinkedServers() {
        if let data = try? JSONEncoder().encode(linkedServers) {
            UserDefaults.standard.set(data, forKey: "linkedServers")
        }

        if let data = try? JSONEncoder().encode(ownedServers) {
            UserDefaults.standard.set(data, forKey: "ownedServers")
        }
    }

    private func saveMembershipData() {
        UserDefaults.standard.set(membershipLevel.rawValue, forKey: "membershipLevel")

        if let data = try? JSONEncoder().encode(membershipStats) {
            UserDefaults.standard.set(data, forKey: "membershipStats")
        }

        UserDefaults.standard.set(paidTier.rawValue, forKey: "paidTier")
        UserDefaults.standard.set(complaints, forKey: "complaints")
        UserDefaults.standard.set(trustScore, forKey: "trustScore")
    }

    private func getClientId() -> String {
        if let clientId = UserDefaults.standard.string(forKey: "clientId") {
            return clientId
        }
        let newId = UUID().uuidString
        UserDefaults.standard.set(newId, forKey: "clientId")
        return newId
    }

    // MARK: - NFT Server Transfer

    func transferServer(_ server: OwnedServer, toWalletAddress: String, completion: @escaping (Bool, TransferResult?) -> Void) {
        // Initiate NFT transfer
        guard let url = URL(string: "\(server.url)/api/transfer") else {
            completion(false, nil)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let body: [String: Any] = [
            "serverId": server.id,
            "toWallet": toWalletAddress,
            "fromWallet": server.ownerWallet ?? "",
            "includeData": true // Transfer without data loss
        ]

        request.httpBody = try? JSONSerialization.data(withJSONObject: body)

        URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            DispatchQueue.main.async {
                guard let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let success = json["success"] as? Bool, success else {
                    completion(false, nil)
                    return
                }

                let result = TransferResult(
                    transactionId: json["transactionId"] as? String ?? "",
                    serverDownloadUrl: json["serverDownload"] as? String,
                    appDownloadUrl: json["appDownload"] as? String,
                    newOwnerWallet: toWalletAddress,
                    transferredAt: Date()
                )

                // Remove from owned servers
                self?.ownedServers.removeAll { $0.id == server.id }
                self?.saveLinkedServers()

                completion(true, result)
            }
        }.resume()
    }
}

// MARK: - Models

struct LinkedServer: Codable, Identifiable {
    let id: String
    let name: String
    let url: String
    let ownerId: String?
    let pairedAt: Date
    var accessToken: String?
    var isOnline: Bool = false
    var authMethod: AuthMethod = .pairingCode
    var authUserId: String?
    var authUsername: String?
}

struct OwnedServer: Codable, Identifiable {
    let id: String
    let name: String
    let url: String
    let ownerWallet: String?
    let mintedAt: Date?
    let nftTokenId: String?
    var isRunning: Bool = false
}

struct DiscoveredServer: Identifiable {
    let id = UUID()
    let name: String
    let url: String
    let port: Int
    let serverId: String?
    let isPaired: Bool
}

struct TransferResult {
    let transactionId: String
    let serverDownloadUrl: String?
    let appDownloadUrl: String?
    let newOwnerWallet: String
    let transferredAt: Date
}

// MARK: - Notifications

extension Notification.Name {
    static let serverLinked = Notification.Name("serverLinked")
    static let serverUnlinked = Notification.Name("serverUnlinked")
    static let serverTransferred = Notification.Name("serverTransferred")
    static let membershipLevelChanged = Notification.Name("membershipLevelChanged")
    static let trustScoreChanged = Notification.Name("trustScoreChanged")
}
